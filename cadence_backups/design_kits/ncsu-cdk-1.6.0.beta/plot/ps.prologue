%!PS-Adobe-3.0
%%DocumentFonts: Helvetica Times-Roman Courier
%%Creator: Cadence Design Systems
%%EndComments
%%BeginProlog
%
% Start of Cadence ps.prologue -- Version 5.1.1
% Adobe Postscript Level 2 Color Version.  
%******************************************************************************
% Graphics initialization routine.
%
/gis  {
%  setpage
  save
  mark
  newpath

%
% Scale postscripts 72 dpi divided by the plotter resolution set in pap.
%
  72 resolution div
  dup
  scale

%
% Move the origin of the plot up and to the right so the plotters margin
% is observed.
%
  offsetX offsetY translate

  /stippleArray 10 array def
    stippleArray
     dup    0  <FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
                FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF> put
     dup    1  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    2  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    3  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    4  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    5  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    6  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    7  <00000000000000000000000000000000
                00000000000000000000000000000000> put
     dup    8  <08080404020201018080404020201010
		08080404020201018080404020201010> put
            9  <08081414222241418080414122221414
                08081414222241418080414122221414> put

  /newFont 10 dict def 
  newFont begin

    /FontType 3 def
    /FontMatrix [1 0 0 1 0 0] def
    /FontBBox [0 0 1 1] def

    /Encoding 256 array def
    0 1 255 {Encoding exch /.notdef put} for
    Encoding
      dup 48 /0  put
      dup 49 /1  put
      dup 50 /2  put
      dup 51 /3  put
      dup 52 /4  put
      dup 53 /5  put
      dup 54 /6  put
      dup 55 /7  put
      dup 56 /8  put
          57 /9  put


    /BuildChar {
        /char exch def
        /fontdict exch def
        /charname fontdict /Encoding get char get def

         1 0 setcharwidth

          16 16 true
          [16 0 0 -16 -.5 15.50]
           stippleArray char 48 sub 1 getinterval cvx
          imagemask
    } def

  end
  /StippleFont newFont definefont 66 scalefont setfont
  /fillChar 0 def

  /ellipsedict 8 dict def
  ellipsedict /mtrx matrix put

  /xformdict 6 dict def
  xformdict /xformmtrx matrix put

  /color     0 def

  /lineRed   0 def
  /lineGreen 0 def
  /lineBlue  0 def

  /fillRed   0 def
  /fillGreen 0 def
  /fillBlue  0 def

  /hatchSet  0 def

} bind def

%******************************************************************************
% set page device. Sets the page size for newer PS versions.
%
/setpage {
%
% If setpagedevice is defined in the systemdict, then call it
%
    systemdict /setpagedevice known
    {
	mark
	/PageSize [ pageWidth offsetX offsetX add add 72 mul resolution idiv
	pageHeight offsetY offsetY add add 72 mul resolution idiv ]
	/ImagingBBox null
	counttomark 2 idiv dup dict begin {def} repeat pop currentdict end
%	<</PageSize [papx papy] /ImagingBBox null>> setpagedevice
	setpagedevice
    } if
} bind def

%******************************************************************************
% Paper call.  Sets resolution page height and page width.
%
/pap {
    /resolution exch def
    /pageHeight exch def
    /pageWidth exch def
    /offsetY exch def
    /offsetX exch def

  } bind def

%******************************************************************************
% Plot is done.
%
/gfs  {
    showpage 
    cleartomark
    restore
  } bind def

%******************************************************************************
% Next Page sequence.
%
/nxp  {

    showpage
    newpath

%
% Scale postscripts 72 dpi divided by the plotter resolution set in pap.
%
    72 resolution div
    dup
    scale
%
% Move the origin of the plot up and to the right so the plotters margin
% is observed.
%
    offsetX offsetY translate

  } bind def

%******************************************************************************
% Rotate Plot Sequence.
%
/rotp  {
  pageWidth 0  translate  %% This moves lower left of plot to 
                          %% lower right of page.

  90 rotate    %% rotate plot 90 degs. 
} bind def
%******************************************************************************
% Clipping Window
%
/clwin  {
    initclip
    /y2 exch def
    /x2 exch def
    /y1 exch def
    /x1 exch def
    newpath 
    x1 y1 moveto
    x2 y1 lineto 
    x2 y2 lineto 
    x1 y2 lineto 
    closepath
    clip
} bind def
%******************************************************************************
% These to routines keep track of the bounding box of the shape.
% This information is used when filling the drawn shape.
%
/bblineto {
  dup dup
  /cury exch def
  miny lt {/miny exch def}
    {dup maxy gt { /maxy exch def }
           {pop } ifelse } ifelse
  dup dup
  minx lt {/minx exch def}
    {dup maxx gt { /maxx exch def }
           { pop } ifelse } ifelse
  cury lineto
} bind def

/bbmoveto {
  dup dup
  /miny exch def /maxy exch def /cury exch def
  dup dup
  /minx exch def /maxx exch def
  cury moveto
} bind def
%******************************************************************************
% Internal ellipical arc routine.
%    x y xradius yradius startangle endangle ellipse
%
/ellipse 
  {
    /endangle exch def
    /startangle exch def
    /yrad exch def
    /xrad exch def
    /y exch def
    /x exch def

    startangle endangle gt {
      save
      /tmpangle startangle def
      /startangle endangle def
      /endangle tmpangle def
      restore
    } if

    ellipsedict begin
      /savematrix mtrx currentmatrix def
      x y translate
      xrad yrad scale
      0 0 1 startangle endangle arc
      savematrix setmatrix
    end
  } bind def
%******************************************************************************
% Resident Font Scale Sequence
%    x y rfss
%
/rfss  {
    4 2 roll
    dup
    3 div
    add
    scalefont 
    setfont
    0 color ne {setLineColor}
               { 0 setgray } ifelse
  } bind def
%******************************************************************************
% Resident Font End
%    
%
/rfe
{
/width exch def
5 1 roll
moveto
    
xformdict begin
/savematrix xformmtrx currentmatrix def

exch 				% rotate mirror to mirror rotate
matrix rotate concat		% add rotation to current transform matrix
dup 1 eq
	{pop 1 -1}		% X mirror

	{2 eq
		{-1 1}		% Y mirror
		{1 1}		% No mirror
	ifelse}
ifelse matrix scale concat	% add mirror to current transform matrix


dup				% duplicate (string)
length				% replace one of the strings with its length
dup 0 ne
{
	3 -1 roll		% move fixed width flag to top of stack
	0 eq
	{			% if flag is false (0) do old string handling
		/numChr exch def
		dup stringwidth	%stack  wy,wx,(string)
		pop
		width
		exch sub	%stack  xdiff,ydiff,(string)

		cvi
		numChr idiv	%stack  xspace,ydiff,(string)

		/xoff exch def

		{		% this is the positioning  function for kshow
			pop pop
			xoff
			0
			rmoveto
		}

		exch
		kshow
	}

	{			% if flag is true (not 0) just show string
		pop show
	}
	ifelse
}

{
	pop pop pop
}
ifelse
      savematrix setmatrix
    end
  } bind def
%******************************************************************************
% Draw line sequence.
%
/dls  {
  newpath
  moveto
  rlineto
  gsave
  0 color ne { setLineColor }
             { 0 setgray } ifelse
  stroke
  grestore
} bind def
%******************************************************************************
% Draw line to.
%
/dlt  {
  newpath
  gsave
  0 color ne { setLineColor }
             { 0 setgray } ifelse
  moveto 
} bind def
%******************************************************************************
%
/dslt  { 
  newpath
  gsave
  0 color ne { setLineColor }
             { 0 setgray } ifelse
  moveto 
} bind def
%******************************************************************************
%
/dlv  { 
  rlineto 
} bind def
%******************************************************************************
%
/dle  { 
  stroke
  grestore
} bind def
%******************************************************************************
% Move to.
/mps {
  newpath
  moveto 
} bind def
%******************************************************************************
%
% Draw Box Unfilled
%    x1 y1 x2 y2 dbu
%
/dbu  { 
    0 color ne { setLineColor } if
    newpath
    moveto
    dup 0 rlineto
    0 3 -1 roll
    rlineto
    neg 0 rlineto
    closepath
    stroke
  } bind def
%******************************************************************************
%
% Draw Box Filled
%    x1 y1 x2 y2 dbf
%
/dbf  { 
    /y2 exch def
    /x2 exch def
    /y1 exch def
    /x1 exch def
    newpath
    x1 y1 bbmoveto
    x2 y1 bblineto
    x2 y2 bblineto
    x1 y2 bblineto
    closepath
    gsave 
    0 color ne { setFillColor } if
    clip fillpath grestore
  } bind def
%******************************************************************************
% Draw Box Solid
%    x1 y1 x2 y2 dsb
%
/dbs  {
    /y2 exch def
    /x2 exch def
    /y1 exch def
    /x1 exch def
    newpath 
    x1 y1 moveto
    x2 y1 lineto 
    x2 y2 lineto 
    x1 y2 lineto 
    closepath
    gsave
    0 color ne { setFillColor }
               { 0 setgray } ifelse
    fill 
    stroke 
    grestore
  } bind def

%******************************************************************************
% Draw Polygon Begin
%    x y dpb
%
/dpb  { 
    newpath bbmoveto
  } bind def

%******************************************************************************
% Draw Polygon Unfilled
%    x y dpu
%
/dpu  { 
      closepath
      gsave
      0 color ne { setLineColor } if
      stroke
      grestore
   } bind def

%******************************************************************************
% Draw Polygon Filled
%    x y dpf
%
/dpf  { 
    closepath
    gsave
    0 color ne { setFillColor } if
    clip fillpath grestore
  } bind def

%******************************************************************************
% Draw Polygon Solid
%    x y dps
%
/dps  { 
    closepath
    gsave 
    0 color ne { setFillColor }
               { 0 setgray } ifelse
    fill stroke
    grestore
  } bind def

%******************************************************************************
% Draw Polygon Vertex
%    x y dpv
%
/dpv  { 
    bblineto
  } bind def

%******************************************************************************
% Draw Circle Unfilled
%    x y radius dcu
%
/dcu  { 
    /radius exch def
    /y exch def
    /x exch def

    newpath 
    x y radius radius 0 360 ellipse
    gsave
    0 color ne { setLineColor } if
    stroke
    grestore
  } bind def
%******************************************************************************
% Draw Circle Filled
%    x y radius dcs
%
/dcf  { 
    /radius exch def
    /y exch def
    /x exch def
    /minx x radius sub def
    /miny y radius sub def
    /maxx x radius add def
    /maxy y radius add def

    newpath 
    x y radius radius 0 360 ellipse
    gsave
    0 color ne { setFillColor } if
    clip fillpath
    grestore
  } bind def

%******************************************************************************
% Draw Circle Solid
%    x y radius dcs
%
/dcs  { 
    /radius exch def
    /y exch def
    /x exch def

          newpath 
    x y radius radius 0 360 ellipse
    gsave
    0 color ne { setFillColor }
               { 0 setgray } ifelse
    fill stroke
    grestore
  } bind def
%******************************************************************************
% Draw Ellipse Unfilled
%    x y xradius yradius deu
%
/delu  { 
    /yradius exch def
    /xradius exch def
    /y exch def
    /x exch def
    
    newpath
    x y xradius yradius 0 360 ellipse 
    gsave
    0 color ne { setLineColor } if
    stroke
    grestore
  } bind def
%******************************************************************************
% Draw Ellipse Filled
%    x y xradius yradius def
%
/delf  { 
    /yradius exch def
    /xradius exch def
    /y exch def
    /x exch def
    /minx x xradius sub def
    /miny y yradius sub def
    /maxx x xradius add def
    /maxy y yradius add def
    
    newpath
    x y xradius yradius 0 360 ellipse 
    gsave
    0 color ne { setFillColor } if
    clip fillpath
    grestore
  } bind def

%******************************************************************************
% Draw Ellipse Solid
%    x y xradius yradius des
%
/dels  { 
    /yradius exch def
    /xradius exch def
    /y exch def
    /x exch def

    newpath
    x y xradius yradius 0 360 ellipse 
    gsave
    0 color ne { setFillColor }
               { 0 setgray } ifelse

    fill
    stroke 
    grestore 
  } bind def
%******************************************************************************
% Draw Arc Unfilled
%    x y xradius yradius startangle endangle das
%
/dau  { newpath ellipse 
        gsave
        0 color ne { setLineColor } if
        stroke 
        grestore
      } bind def
%******************************************************************************
% Line Define Code.
%
/setlinedash {
    1 index length 11 gt
    {exch dup length 11 sub 11 getinterval exch } if
    setdash
  } bind def

/lpb    { 
    pop
    [
    /offset 0 def
    /offcount 0 def
    /oncount 0 def
  } bind def

/lpon  { 
    /oncount exch def
    pop
    oncount
  } bind def

/lpoff  { 
    /offcount exch def
    pop
    oncount 0 eq
    {/offset offcount def }
    { offcount } ifelse
  } bind def

/lpe  { 
    /linewidth exch def
    pop
    offset 0 ne
    { offset } if ] 0 setlinedash
    linewidth dup 1 eq {pop 0} if setlinewidth
  } bind def

/sls    { pop } bind def

/ssls  { [] 0 setdash 
          1 setlinewidth
        } bind def

%******************************************************************************
% Fill pattern define code.
%
/fillpath  {    
    0 color ne { setFillColor } if
    /str 1 string def
    /minx minx 66 div
    truncate 66 mul def
    /miny miny 66 div
    truncate 66 mul def

          /fillLine maxx minx sub cvi 66 idiv 1 add string def

          0 1 fillLine length 1 sub {
            fillLine exch fillChar str cvs cvi 48 add put
          } for

          minx
          miny 66 maxy
            { exch dup 3 -1 roll moveto fillLine show
          } for pop

    hatchSet 1 eq {stroke} if
} bind def


/fds  { pop /currchar 30 def} bind def
/fdf   {
    exch
    /char exch def
    /stipple stippleArray char get def
    stipple exch currchar
    exch putinterval
    stippleArray char stipple put
    /currchar currchar 2 sub def
  } bind def
/fde  { 
    pop
  } bind def
/sfp  {
    /fillChar exch def
    /hatchSet 0 def
    fillChar 8 ge {/hatchSet 1 def} if
    /StippleFont findfont 66 scalefont setfont
  } bind def
/setLineColor {
  lineRed    1000 div
  lineGreen  1000 div
  lineBlue   1000 div
  setrgbcolor
} bind def

/setFillColor {
  fillRed    1000 div
  fillGreen  1000 div
  fillBlue   1000 div
  setrgbcolor
} bind def

/slc {
  /lineBlue  exch def
  /lineGreen exch def
  /lineRed   exch def
  /color 1 def
  lineBlue 1000 eq {lineGreen 1000 eq {lineRed 1000 eq {
    /lineBlue  0 def
    /lineGreen 0 def
    /lineRed   0 def
  } if} if} if
} bind def

/sfc {
  /fillBlue  exch def
  /fillGreen exch def
  /fillRed   exch def
  /color 1 def
  fillBlue 1000 eq {fillGreen 1000 eq {fillRed 1000 eq {
    /fillBlue  0 def
    /fillGreen 0 def
    /fillRed   0 def
  } if} if} if
} bind def
%******************************************************************************
%
% End of Cadence ps.prologue 
%
%******************************************************************************
%%EndProlog
