// MAX TB Test Protocol File, generated by MAX TB Version G-2012.06
// Mon Apr 30 17:19:40 2018
// Module under test: mips
// Generated from original STIL file : "mips.stil"
// STIL file version: "1.0"
// Simulation mode: default serial simulation

`define TDATA_FILE "/home/seas/willh99/ece128/project/hw_files/mipstb.dat"
`timescale 1ns/1ns

// OPCODE DEFINITION
`define EndPat 0
`define IncPat 1
`define SetPat 2
`define WFTStmt 3
`define ConditionStmt 4
`define VectorStmt 5
`define FixedStmt 6
`define test_setupStmt 7
`define load_unloadStmt 8
`define multiclock_captureStmt 9
`define allclock_launch_captureStmt 10
`define allclock_launchStmt 11
`define allclock_captureStmt 12

// SIGS DEFINITION
`define clk 0
`define reset 1
`define \memdata[7]  2
`define \memdata[6]  3
`define \memdata[5]  4
`define \memdata[4]  5
`define \memdata[3]  6
`define \memdata[2]  7
`define \memdata[1]  8
`define \memdata[0]  9
`define test_si 10
`define test_se 11
`define memread 12
`define memwrite 13
`define \adr[7]  14
`define \adr[6]  15
`define \adr[5]  16
`define \adr[4]  17
`define \adr[3]  18
`define \adr[2]  19
`define \adr[1]  20
`define \adr[0]  21
`define \writedata[7]  22
`define \writedata[6]  23
`define \writedata[5]  24
`define \writedata[4]  25
`define \writedata[3]  26
`define \writedata[2]  27
`define \writedata[1]  28
`define \writedata[0]  29
`define test_so 30
`define _pi 31
`define all_inputs 32
`define _po 33
`define _si 34
`define all_outputs 35
`define _clk 36
`define _so 37

// WFTS DEFINITION
`define _multiclock_capture_WFT_ 0
`define _default_WFT_ 1
`define _allclock_launch_capture_WFT_ 2
`define _allclock_launch_WFT_ 3
`define _allclock_capture_WFT_ 4
`define MAX_PART 0

`define MAXTB_HEADER " MAX TB Version G-2012.06\n Test Protocol File generated from original file \"mips.stil\"\n STIL file version: 1.0"
`define MAXTB_H_S "#############################################################################"


module /* maxtb */ mips_test ();
   parameter NSTMTS = 13; // number of all stmts
   parameter DFSHIFTS = 0; // (default) number of serial shifts in parallel scan mode
   parameter NAMELENGTH = 200; // max length of names reported in fails
   parameter MAXCHLEN = 132, NCHAINS = 1; // MAXCHLEN for serial
   parameter NINPUTS = 12, NOUTPUTS = 19, CUM_WIDTH=96;
   parameter NSIS = 1, NSOUTS = 1;
   parameter WFT_IDS = 5, SIG_IDS = 38, SIG_IDS_W = 6, MAX_WIDTH = 19, MAX_SIGW = 1;
   parameter PARSERINC = 132; 
   parameter SYNC_LATENCY = 3; 
   parameter PRTIME = 0.000000; 
   integer xtb_sim_mode; // simulation modes: xtb_sim_mode=0 -> serial, xtb_sim_mode=1 -> parallel (default);
   integer nbfails, abit, cbit;
   integer prev_error; // flag for tracking displayed error banner
   integer loads;        // number of load_unloads for current pattern
   integer prev_pat;     // previous pattern number;
   integer rep_pat; // report pattern progress every Nth pattern
   integer verbose;      // message verbosity level
   integer data_i, n, cur_pat, start_pat, end_pat, last_pat, total_pats, csci, fsci, cur_stmt;
   integer v_count, v_count_per_pat;  // track the cycle count and cycle/pattern count (helpful for the simulator GUI)
   integer SSHIFTS;
   integer diagf, diagm;
   integer sertmg;
   integer the_wft_id, wft_id_s;
   integer ser_pats;
   integer first_pat;
   event start_part, end_part;

   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] ALLINSIGS, ALLOUTSIGS;
   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] TMPINSIGS_V,TMPINSIGS_T,TMPINSIGS_V_S,TMPINSIGS_T_S;
   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] TMPOUTSIGS_V,TMPOUTSIGS_T,TMPOUTSIGS_V_S,TMPOUTSIGS_T_S;
   reg [NINPUTS+NOUTPUTS-1:0] ALLINSIGIDS, ALLOUTSIGIDS, ALLINSIGIDS_S, ALLOUTSIGIDS_S;
   reg [NSTMTS-1:0] opcode, popcode;
   event force_scells;
   event strobe_scells;
   event release_scells;
   reg [137:0] memel, memall [1:2141];
   reg [0:(8*NAMELENGTH)-1] CH_NAMES [0:NCHAINS-1];
   reg [0:(8*NAMELENGTH)-1] CH_PINS [0:NCHAINS-1];
   reg [0:MAXCHLEN-1] LOD, LOAD[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] UNL, UNLOAD[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] UNLM, UNLMSK[0:NCHAINS-1], SHBEGM[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] SERIALM;
   reg [0:MAXCHLEN-1] CH_INPINV[0:NCHAINS-1], CH_OUTINV[0:NCHAINS-1];
   wire [0:NCHAINS-1] SCANOUT;
   reg [0:MAXCHLEN-1] CHOUT, CHAINOUT[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] CHAINOUT0;
   reg [0:MAXCHLEN-1] LOD0;
   reg [5:0] the_sids [0:SIG_IDS-1];
   reg [MAX_WIDTH-1:0] the_sigs [0:SIG_IDS-1];
   reg strobe_en;
   reg [SIG_IDS-1:0] sid_args ;
   reg [2*CUM_WIDTH-1:0] sval_args;
   reg [8*NAMELENGTH-1:0]  SignalIDName [0:37];
   reg [2:0]  SignalIDType [0:37];
   reg [4:0]  SignalIDWidth [0:37];
   reg [(8*NAMELENGTH-1):0]  WFTIDName [0:4];
   reg [0:(8*NAMELENGTH-1)] StmtNames [0:NSTMTS];
   reg [0:(8*NAMELENGTH-1)] diag_file;

   reg clk ;
   reg reset ;
   reg \memdata[7]  ;
   reg \memdata[6]  ;
   reg \memdata[5]  ;
   reg \memdata[4]  ;
   reg \memdata[3]  ;
   reg \memdata[2]  ;
   reg \memdata[1]  ;
   reg \memdata[0]  ;
   reg test_si ;
   reg test_se ;
   wire memread ;
   wire memwrite ;
   wire \adr[7]  ;
   wire \adr[6]  ;
   wire \adr[5]  ;
   wire \adr[4]  ;
   wire \adr[3]  ;
   wire \adr[2]  ;
   wire \adr[1]  ;
   wire \adr[0]  ;
   wire \writedata[7]  ;
   wire \writedata[6]  ;
   wire \writedata[5]  ;
   wire \writedata[4]  ;
   wire \writedata[3]  ;
   wire \writedata[2]  ;
   wire \writedata[1]  ;
   wire \writedata[0]  ;
   wire test_so ;

   wire [0:(8*NAMELENGTH-1)] cur_StmtName;
   assign cur_StmtName = StmtNames[cur_stmt] ;


   mips dut( 
     .clk ( clk ),
     .reset ( reset ),
     .memdata ( { \memdata[7] ,
        \memdata[6] ,
        \memdata[5] ,
        \memdata[4] ,
        \memdata[3] ,
        \memdata[2] ,
        \memdata[1] ,
        \memdata[0] } ),
     .test_si ( test_si ),
     .test_se ( test_se ),
     .memread ( memread ),
     .memwrite ( memwrite ),
     .adr ( { \adr[7] ,
        \adr[6] ,
        \adr[5] ,
        \adr[4] ,
        \adr[3] ,
        \adr[2] ,
        \adr[1] ,
        \adr[0] } ),
     .writedata ( { \writedata[7] ,
        \writedata[6] ,
        \writedata[5] ,
        \writedata[4] ,
        \writedata[3] ,
        \writedata[2] ,
        \writedata[1] ,
        \writedata[0] } ),
     .test_so ( test_so )
  );


   task save_context;
     begin
       wft_id_s = the_wft_id;
       TMPINSIGS_V_S = TMPINSIGS_V;
       TMPOUTSIGS_V_S = TMPOUTSIGS_V;
       TMPINSIGS_T_S = TMPINSIGS_T;
       TMPOUTSIGS_T_S = TMPOUTSIGS_T;
       ALLOUTSIGIDS_S = ALLOUTSIGIDS;
       ALLINSIGIDS_S = ALLINSIGIDS;
     end
   endtask 

   task restore_context;
     begin
       the_wft_id = wft_id_s;
       TMPINSIGS_V = TMPINSIGS_V_S;
       TMPOUTSIGS_V = TMPOUTSIGS_V_S;
       TMPINSIGS_T = TMPINSIGS_T_S;
       TMPOUTSIGS_T = TMPOUTSIGS_T_S;
       ALLOUTSIGIDS = ALLOUTSIGIDS_S;
       ALLINSIGIDS = ALLINSIGIDS_S;
     end
   endtask 

   task resolve_signal;
     input [5:0] sid;
	  reg [5:0] sid;
   begin
     if (SignalIDType[sid] != 3) the_sids[0] = sid;
     else begin
       case (sid)
         'd31: begin // _pi
                 the_sids[11] = 0; the_sids[10] = 9; the_sids[9] = 8; the_sids[8] = 7; the_sids[7] = 6; the_sids[6] = 5; the_sids[5] = 4; the_sids[4] = 3; the_sids[3] = 2; the_sids[2] = 1; the_sids[1] = 10;
                 the_sids[0] = 11;
               end
         'd32: begin // all_inputs
                 the_sids[11] = 0; the_sids[10] = 9; the_sids[9] = 8; the_sids[8] = 7; the_sids[7] = 6; the_sids[6] = 5; the_sids[5] = 4; the_sids[4] = 3; the_sids[3] = 2; the_sids[2] = 1; the_sids[1] = 10;
                 the_sids[0] = 11;
               end
         'd33: begin // _po
                 the_sids[18] = 21; the_sids[17] = 20; the_sids[16] = 19; the_sids[15] = 18; the_sids[14] = 17; the_sids[13] = 16; the_sids[12] = 15; the_sids[11] = 14; the_sids[10] = 12; the_sids[9] = 13; the_sids[8] = 29; the_sids[7] = 28; the_sids[6] = 27; the_sids[5] = 26; the_sids[4] = 25; the_sids[3] = 24; the_sids[2] = 23; the_sids[1] = 22;
                 the_sids[0] = 30;
               end
         'd34: begin // _si
                
                 the_sids[0] = 10;
               end
         'd35: begin // all_outputs
                 the_sids[18] = 21; the_sids[17] = 20; the_sids[16] = 19; the_sids[15] = 18; the_sids[14] = 17; the_sids[13] = 16; the_sids[12] = 15; the_sids[11] = 14; the_sids[10] = 12; the_sids[9] = 13; the_sids[8] = 29; the_sids[7] = 28; the_sids[6] = 27; the_sids[5] = 26; the_sids[4] = 25; the_sids[3] = 24; the_sids[2] = 23; the_sids[1] = 22;
                 the_sids[0] = 30;
               end
         'd36: begin // _clk
                
                 the_sids[0] = 0;
               end
         'd37: begin // _so
                
                 the_sids[0] = 30;
               end
          default: begin $display("\nXTB Error: unrecognized signal id %d (valid range is 0..%d). Exiting...",sid, SIG_IDS); $finish; end
       endcase
     end
   end
   endtask

   task get_stb_sig;
     input [5:0] sid ; 
     reg [5:0] sid ;
     output [MAX_WIDTH-1:0] strsig;
     reg [MAX_WIDTH-1:0] strsig;
   begin
     case (sid)
       'd12:	strsig[0:0] = 	memread ;
       'd13:	strsig[0:0] = 	memwrite ;
       'd14:	strsig[0:0] = 	\adr[7]  ;
       'd15:	strsig[0:0] = 	\adr[6]  ;
       'd16:	strsig[0:0] = 	\adr[5]  ;
       'd17:	strsig[0:0] = 	\adr[4]  ;
       'd18:	strsig[0:0] = 	\adr[3]  ;
       'd19:	strsig[0:0] = 	\adr[2]  ;
       'd20:	strsig[0:0] = 	\adr[1]  ;
       'd21:	strsig[0:0] = 	\adr[0]  ;
       'd22:	strsig[0:0] = 	\writedata[7]  ;
       'd23:	strsig[0:0] = 	\writedata[6]  ;
       'd24:	strsig[0:0] = 	\writedata[5]  ;
       'd25:	strsig[0:0] = 	\writedata[4]  ;
       'd26:	strsig[0:0] = 	\writedata[3]  ;
       'd27:	strsig[0:0] = 	\writedata[2]  ;
       'd28:	strsig[0:0] = 	\writedata[1]  ;
       'd29:	strsig[0:0] = 	\writedata[0]  ;
       'd30:	strsig[0:0] = 	test_so ;
       default: begin $display("\nXTB Error: unrecognized output signal id %d. Exiting...",sid); $finish; end
     endcase
   end
   endtask

   task set_force_sig;
     input  [SIG_IDS-1:0] sid ;
     reg [SIG_IDS-1:0] sid ;
   begin
     case (sid)
       'd0: clk 	= ALLINSIGS[sid];
       'd1: reset 	= ALLINSIGS[sid];
       'd2: \memdata[7]  	= ALLINSIGS[sid];
       'd3: \memdata[6]  	= ALLINSIGS[sid];
       'd4: \memdata[5]  	= ALLINSIGS[sid];
       'd5: \memdata[4]  	= ALLINSIGS[sid];
       'd6: \memdata[3]  	= ALLINSIGS[sid];
       'd7: \memdata[2]  	= ALLINSIGS[sid];
       'd8: \memdata[1]  	= ALLINSIGS[sid];
       'd9: \memdata[0]  	= ALLINSIGS[sid];
       'd10: test_si 	= ALLINSIGS[sid];
       'd11: test_se 	= ALLINSIGS[sid];
       default: begin $display("\nXTB Error: unrecognized (input) signal id %d (valid range is 0..%d). Exiting...",sid, SIG_IDS-1); $finish; end
     endcase
   end
   endtask 

   always  begin: force_sigs_p
     reg [SIG_IDS-1:0] sid; 
     reg [MAX_SIGW-1:0] sig;
     fork
        forever @(ALLINSIGS[0]) set_force_sig('d`clk );
        forever @(ALLINSIGS[1]) set_force_sig('d`reset );
        forever @(ALLINSIGS[2]) set_force_sig('d`\memdata[7]  );
        forever @(ALLINSIGS[3]) set_force_sig('d`\memdata[6]  );
        forever @(ALLINSIGS[4]) set_force_sig('d`\memdata[5]  );
        forever @(ALLINSIGS[5]) set_force_sig('d`\memdata[4]  );
        forever @(ALLINSIGS[6]) set_force_sig('d`\memdata[3]  );
        forever @(ALLINSIGS[7]) set_force_sig('d`\memdata[2]  );
        forever @(ALLINSIGS[8]) set_force_sig('d`\memdata[1]  );
        forever @(ALLINSIGS[9]) set_force_sig('d`\memdata[0]  );
        forever @(ALLINSIGS[10]) set_force_sig('d`test_si );
        forever @(ALLINSIGS[11]) set_force_sig('d`test_se );
     join
   end

   task measure_out_sig;
     input [SIG_IDS-1:0] sid ;
     input [MAX_WIDTH-1:0] xsig;
     input stmtid;
     reg [MAX_WIDTH-1:0] csig;
     reg [SIG_IDS-1:0] sid ;
     reg [MAX_WIDTH-1:0] xsig;
     integer errshown, abit, cpat, stmtid;
   begin
     errshown = 0;
     cpat = cur_pat < 0 ? 0 : cur_pat;
     get_stb_sig(sid,csig);
     for (abit = 0; abit < SignalIDWidth[sid]; abit = abit + 1) begin
       if (xsig[abit] !== 1'bx) begin
         if (xsig[abit] !== csig[abit]) begin
           if (errshown == 0) $display(">>>  Error during %0s pattern %0d", StmtNames[stmtid], cpat);
           if (SignalIDWidth[sid] <= 1) begin 
             $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, signal %0s", $time, v_count, xsig[abit], csig[abit], SignalIDName[sid]);
             if (diagf) begin 
               if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b)", SignalIDName[sid], v_count, xsig[abit], csig[abit]);
               else $fdisplay(diagf, "  %0d %0s (exp=%b, got=%b)", cpat, SignalIDName[sid], xsig[abit], csig[abit]);
             end 
           end 
           else begin 
             $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, signal %0s[%0d]", $time, v_count, xsig[abit], csig[abit], SignalIDName[sid], abit);
             if (diagf) begin 
               if (diagm==2) $fdisplay(diagf, "  C %0s[%0d] %0d (exp=%b, got=%b)", SignalIDName[sid], abit, v_count, xsig[abit], csig[abit]);
               else $fdisplay(diagf, "  %0d %0s[%d] (exp=%b, got=%b)", cpat, SignalIDName[sid], abit, xsig[abit], csig[abit]);
             end 
           end 
           nbfails = nbfails + 1;
           errshown = 1;
         end 
       end 
     end 
   end 
   endtask

   task measure_scan_out;
     input [SIG_IDS-1:0] sid ;
     input [MAX_WIDTH-1:0] xsig;
     input chain;
     reg [SIG_IDS-1:0] sid ;
     reg [MAX_WIDTH-1:0] xsig;
     reg [MAX_WIDTH-1:0] csig;
     integer errshown, patoff, chain;
   begin
     errshown = 0;
     get_stb_sig(sid, csig);
     if ((xsig[0] !==1'bx) && (xsig[0] !== csig[0])) begin
       patoff = (loads > 1 || cur_pat <= 0) ? 0 : 1;
       if (prev_error != cur_pat) begin
         if (cur_pat <= 0 || cur_pat == last_pat && loads > 1) begin
           $display(">>>  Error during scan pattern %0d %s", (cur_pat < 0) ? 0 : cur_pat,  (cur_pat == last_pat) ? "(detected from final pattern unload)" : "");
         end
         else begin
           if (loads > 1) $display(">>>  Error during scan pattern %0d (detected from %0d load/unload)", cur_pat, loads);
           else begin $display(">>>  Error during scan pattern %0d (detected from unload of pattern %0d)", cur_pat, cur_pat-1); end
         end 
         prev_error = cur_pat;
       end
       $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, chain %0s, pin %0s, scan cell %0d", $time, v_count, xsig[0], csig[0], CH_NAMES[chain], SignalIDName[sid], fsci);
       if (diagf) begin 
         if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b)", SignalIDName[sid], v_count, xsig[0], csig[0]);
          else $fdisplay(diagf, "  %0d %0s %0d (exp=%b, got=%b)", cur_pat-patoff, SignalIDName[sid], fsci, xsig[0], csig[0]);
       end 
       nbfails = nbfails + 1;
     end
   end 
   endtask

   always begin: measure_sigs_p
    fork
     forever @(ALLOUTSIGS['d`memread]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`memread,ALLOUTSIGS[12], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`memwrite]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`memwrite,ALLOUTSIGS[13], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\adr[7] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\adr[7] ,ALLOUTSIGS[14], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\adr[6] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\adr[6] ,ALLOUTSIGS[15], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\adr[5] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\adr[5] ,ALLOUTSIGS[16], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\adr[4] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\adr[4] ,ALLOUTSIGS[17], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\adr[3] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\adr[3] ,ALLOUTSIGS[18], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\adr[2] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\adr[2] ,ALLOUTSIGS[19], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\adr[1] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\adr[1] ,ALLOUTSIGS[20], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\adr[0] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\adr[0] ,ALLOUTSIGS[21], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\writedata[7] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\writedata[7] ,ALLOUTSIGS[22], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\writedata[6] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\writedata[6] ,ALLOUTSIGS[23], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\writedata[5] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\writedata[5] ,ALLOUTSIGS[24], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\writedata[4] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\writedata[4] ,ALLOUTSIGS[25], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\writedata[3] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\writedata[3] ,ALLOUTSIGS[26], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\writedata[2] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\writedata[2] ,ALLOUTSIGS[27], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\writedata[1] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\writedata[1] ,ALLOUTSIGS[28], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`\writedata[0] ]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt ) measure_out_sig('d`\writedata[0] ,ALLOUTSIGS[29], cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`test_so]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `load_unloadStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_captureStmt )
       if (cur_stmt ==`load_unloadStmt) measure_scan_out('d`test_so,ALLOUTSIGS[30], 0); 
       else measure_out_sig('d`test_so,ALLOUTSIGS[30], cur_stmt); 
     end
    join
   end 

   task undef_wfc;
     input [1:0] wfc;
     input [5:0] sid;
     input wftid;
     reg [1:0] wfc;
     reg [5:0] sid;
     integer wftid;

   begin
     $display("XTB Error: unrecognized %s value (WFC):%0b, on signal %0s for WFT %0s. Exiting...", wfc[1]?"strobe":"force", wfc[0], SignalIDName[sid], WFTIDName[wftid]);
     $finish;
   end
   endtask

   task apply__multiclock_capture_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd9, 'd8, 'd7, 'd6, 'd5, 'd4, 'd3, 'd2, 'd1, 'd10, 'd11: // \memdata[0] , \memdata[1] , \memdata[2] , \memdata[3] , \memdata[4] , \memdata[5] , \memdata[6] , \memdata[7] , reset, test_si, test_se
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
         'd21, 'd20, 'd19, 'd18, 'd17, 'd16, 'd15, 'd14, 'd12, 'd13, 'd29, 'd28, 'd27, 'd26, 'd25, 'd24, 'd23, 'd22, 'd30: // \adr[0] , \adr[1] , \adr[2] , \adr[3] , \adr[4] , \adr[5] , \adr[6] , \adr[7] , memread, memwrite, \writedata[0] , \writedata[1] , \writedata[2] , \writedata[3] , \writedata[4] , \writedata[5] , \writedata[6] , \writedata[7] , test_so
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__default_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd9, 'd8, 'd7, 'd6, 'd5, 'd4, 'd3, 'd2, 'd1, 'd10, 'd11: // \memdata[0] , \memdata[1] , \memdata[2] , \memdata[3] , \memdata[4] , \memdata[5] , \memdata[6] , \memdata[7] , reset, test_si, test_se
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
         'd21, 'd20, 'd19, 'd18, 'd17, 'd16, 'd15, 'd14, 'd12, 'd13, 'd29, 'd28, 'd27, 'd26, 'd25, 'd24, 'd23, 'd22, 'd30: // \adr[0] , \adr[1] , \adr[2] , \adr[3] , \adr[4] , \adr[5] , \adr[6] , \adr[7] , memread, memwrite, \writedata[0] , \writedata[1] , \writedata[2] , \writedata[3] , \writedata[4] , \writedata[5] , \writedata[6] , \writedata[7] , test_so
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__allclock_launch_capture_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd9, 'd8, 'd7, 'd6, 'd5, 'd4, 'd3, 'd2, 'd1, 'd10, 'd11: // \memdata[0] , \memdata[1] , \memdata[2] , \memdata[3] , \memdata[4] , \memdata[5] , \memdata[6] , \memdata[7] , reset, test_si, test_se
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 2);
               endcase
             end
           end
         end 
         'd21, 'd20, 'd19, 'd18, 'd17, 'd16, 'd15, 'd14, 'd12, 'd13, 'd29, 'd28, 'd27, 'd26, 'd25, 'd24, 'd23, 'd22, 'd30: // \adr[0] , \adr[1] , \adr[2] , \adr[3] , \adr[4] , \adr[5] , \adr[6] , \adr[7] , memread, memwrite, \writedata[0] , \writedata[1] , \writedata[2] , \writedata[3] , \writedata[4] , \writedata[5] , \writedata[6] , \writedata[7] , test_so
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 2);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 2);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__allclock_launch_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd9, 'd8, 'd7, 'd6, 'd5, 'd4, 'd3, 'd2, 'd1, 'd10, 'd11: // \memdata[0] , \memdata[1] , \memdata[2] , \memdata[3] , \memdata[4] , \memdata[5] , \memdata[6] , \memdata[7] , reset, test_si, test_se
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 3);
               endcase
             end
           end
         end 
         'd21, 'd20, 'd19, 'd18, 'd17, 'd16, 'd15, 'd14, 'd12, 'd13, 'd29, 'd28, 'd27, 'd26, 'd25, 'd24, 'd23, 'd22, 'd30: // \adr[0] , \adr[1] , \adr[2] , \adr[3] , \adr[4] , \adr[5] , \adr[6] , \adr[7] , memread, memwrite, \writedata[0] , \writedata[1] , \writedata[2] , \writedata[3] , \writedata[4] , \writedata[5] , \writedata[6] , \writedata[7] , test_so
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 3);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 3);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__allclock_capture_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd9, 'd8, 'd7, 'd6, 'd5, 'd4, 'd3, 'd2, 'd1, 'd10, 'd11: // \memdata[0] , \memdata[1] , \memdata[2] , \memdata[3] , \memdata[4] , \memdata[5] , \memdata[6] , \memdata[7] , reset, test_si, test_se
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 4);
               endcase
             end
           end
         end 
         'd21, 'd20, 'd19, 'd18, 'd17, 'd16, 'd15, 'd14, 'd12, 'd13, 'd29, 'd28, 'd27, 'd26, 'd25, 'd24, 'd23, 'd22, 'd30: // \adr[0] , \adr[1] , \adr[2] , \adr[3] , \adr[4] , \adr[5] , \adr[6] , \adr[7] , memread, memwrite, \writedata[0] , \writedata[1] , \writedata[2] , \writedata[3] , \writedata[4] , \writedata[5] , \writedata[6] , \writedata[7] , test_so
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin    ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 4);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(55) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 4);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task resolve_wft;
     input wftid ;
     integer wftid ;
   begin
     if (wftid > WFT_IDS || wftid <0) begin 
       $display("\nXTB Error: undefined WFT id %0d (valid range is 0..%0d). Exiting...",wftid, WFT_IDS);
       $finish;
     end
     the_wft_id = wftid;
   end
   endtask

   task apply_wft; 
     input wftid ;
     integer wftid ;
   begin
     case (wftid) 
       'd0: apply__multiclock_capture_WFT_WFT;
       'd1: apply__default_WFT_WFT;
       'd2: apply__allclock_launch_capture_WFT_WFT;
       'd3: apply__allclock_launch_WFT_WFT;
       'd4: apply__allclock_capture_WFT_WFT;
       default:begin $display("\nXTB Error: undefined WFT id %d. Exiting...",wftid); $finish; end
     endcase
   end
   endtask 

   task  complete_cycle;
     input wft_id ;
     integer wft_id ;
   begin
     case(wft_id)
       'd0: #(100); // _multiclock_capture_WFT_
       'd1: #(100); // _default_WFT_
       'd2: #(100); // _allclock_launch_capture_WFT_
       'd3: #(100); // _allclock_launch_WFT_
       'd4: #(100); // _allclock_capture_WFT_
     endcase
   end
   endtask

   task set_args;
     input [5:0] nargs;
     integer i, na;
     reg [5:0] nargs;
     reg [2*CUM_WIDTH-1:0] sidx;
     reg [SIG_IDS_W-1:0] sid; 
   begin
     na = 0; sid_args = 'b0; sval_args = 'b0;
     while (na < nargs) begin
       data_i = data_i + 1;
       memel = memall[data_i];
       sid = memel[SIG_IDS_W-1:0];
       if (sid > SIG_IDS-1) begin
         $display($time, "\nXTB Error: Passing wrong signal ID (%0b), valid range is 1..%0d. Exiting...", sid, SIG_IDS-1);
         $finish; 
       end
       sid_args[sid] = 1'b1;
       sidx = sig_idx(sid);
       for (i = 0; i < 2*SignalIDWidth[sid]; i = i + 1)
         sval_args[sidx+i] = memel[i+SIG_IDS_W];
       na=na+1; 
    end  
  end 
  endtask

   function [2*CUM_WIDTH-1:0] sig_idx;
     input [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] sid;
     integer i; 
   begin
     sig_idx = 0;
     for (i = 0; i < sid; i = i + 1) sig_idx = sig_idx+2*SignalIDWidth[i];
   end 
   endfunction

   task  assign_ival;
     input [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] sid;
     reg [2*CUM_WIDTH-1:0] sidx;
     reg [2*MAX_WIDTH-1:0] sval;
     integer i;
   begin 
     sidx = sig_idx(sid);
     for (i = 0; i<2*SignalIDWidth[sid]; i = i + 1) sval[i] = sval_args[sidx+i];
     assign_val(sid , sval);
   end 
   endtask

   task  assign_val;
     input [SIG_IDS_W-1:0] sid;
     input [2*MAX_WIDTH-1:0] sval;
     reg [SIG_IDS_W-1:0] sid;
     reg [2*MAX_WIDTH-1:0] sval;
     reg [MAX_WIDTH-1:0] nb; 
     reg [7:0] idx;
     reg [5:0] n, ns;
   begin
     if (sid > SIG_IDS-1 || sid < 0) begin
       $display("\nXTB Error: Passing wrong signal ID (%d), valid range is 1..%0d. Exiting...", sid, SIG_IDS-1);
       $finish;
     end
     resolve_signal(sid);
     idx = 0; 
     ns = (SignalIDType[sid]==3) ? SignalIDWidth[sid] : 1;
     for (n = 0; n < ns; n = n + 1)
     begin
       if (sval[idx+SignalIDWidth[sid]] === 1'b1) begin
         for (nb = 0; nb < SignalIDWidth[the_sids[n]]; nb = nb + 1) begin
           TMPOUTSIGS_V[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb];
           TMPOUTSIGS_T[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb+SignalIDWidth[sid]];
           ALLOUTSIGIDS[the_sids[n]] = 1'b1; 
           if (sval[idx+nb] !== 1'bx)
             ALLINSIGIDS[the_sids[n]] = 1'b0;
         end
       end
       else begin
         for (nb = 0; nb < SignalIDWidth[the_sids[n]]; nb = nb + 1) begin
           TMPINSIGS_V[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb];
           TMPINSIGS_T[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb+SignalIDWidth[sid]];
           ALLINSIGIDS[the_sids[n]] = 1'b1;
           ALLOUTSIGIDS[the_sids[n]] = 1'b0;
       end 
     end
     idx = idx+SignalIDWidth[the_sids[n]];
     end 
   end 
   endtask

   task  check_sid_args;
     input [(NAMELENGTH-1):0] tname;
     input [SIG_IDS-1:0] vargs ;
     input [SIG_IDS-1:0] cargs ;
     reg [(NAMELENGTH-1):0] tname;
     reg [SIG_IDS-1:0] vargs ;
     reg [SIG_IDS-1:0] cargs ;

     integer i;
   begin
     for (i = 0; i < SIG_IDS-1; i = i + 1)
       if (cargs[i] === 1'b1 && vargs[i] !== 1'b1) begin
         $display("\nXTB Error: Passing wrong signal argument (%s), to Macro/Procedure %s. Exiting...", SignalIDName[i], tname); 
         $finish;
       end 
   end 
   endtask

   task  assign_stmt;
     input wftid ;
     integer wftid ;
   begin
     v_count = v_count+1;
     v_count_per_pat = v_count_per_pat+1;
     if (verbose >= 4) $display("XTB: Starting V# %0d at time %0t", v_count, $time);
     apply_wft(wftid);
     complete_cycle(wftid);
   end
   endtask

   task display_stmt;
     input stmtid;
     integer stmtid;
   begin
     $display("XTB: Processed statement: %0s", StmtNames[stmtid]);
   end
   endtask

   task measure_chain_out;
     input [NCHAINS-1:0] chid;
     reg [NCHAINS-1:0] chid;
     integer bi, errshown, patoff, prefo;
     integer tsc;
     reg [0:MAXCHLEN-1]  UNLM;
   begin
     tsc = 0;
     prefo = 0;
     UNLM = ~('b0);
     CHAINOUT[0] = (CHAINOUT0);
     UNL = UNLOAD[chid] << prefo;
     CHOUT = CHAINOUT[chid] ^ CH_OUTINV[chid];

     for (bi = 0; bi < MAXCHLEN; bi = bi + 1)
       if (UNL[bi] === 1'bx)  UNLM[bi] = 1'b0;

     for (bi = 0; bi < prefo; bi = bi + 1) UNLM[MAXCHLEN-1-bi] = 1'b0;

     if ((UNL&UNLM) !== (CHOUT&UNLM)) begin
       patoff = (loads > 1 || cur_pat <= 0) ? 0 : 1;
     if (cur_pat <= 0 || cur_pat == last_pat && loads > 1) begin
       $display(">>>  Error during scan pattern %0d %s", (cur_pat<0)?0:cur_pat, (cur_pat==last_pat)?"(detected from final parallel pattern unload)":"");
     end
     else begin
       if (loads > 1) $display(">>>  Error during scan pattern %0d (detected from %0d parallel load/unload)", cur_pat, loads);
       else begin $display(">>>  Error during scan pattern %0d (detected from parallel unload of pattern %0d)", cur_pat, cur_pat-1); end
     end
       for (bi = 0; bi < MAXCHLEN-prefo; bi=bi + 1) begin
         if ((UNL[bi] !== 1'bx) && (UNL[bi] !== CHOUT[bi])) begin
           $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, chain %0s, pin %0s, scan cell %0d", $time, sertmg?v_count+1+bi+prefo:v_count, UNL[bi], CHOUT[bi], CH_NAMES[chid], CH_PINS[chid], bi+prefo+tsc);
           if (diagf) begin 
           if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b) ", CH_PINS[chid], v_count, UNL[bi], CHOUT[bi]);
           else $fdisplay(diagf, "  %0d %0s %0d (exp=%b, got=%b)",
               cur_pat-patoff, CH_NAMES[chid], bi+prefo+tsc, UNL[bi], CHOUT[bi]);
           end 
           nbfails = nbfails + 1;
          end 
       end  
     end
   end 
   endtask

   task test_setup;
     input [SIG_IDS-1:0] idargs;
     input [2*CUM_WIDTH-1:0] valargs;
     reg [SIG_IDS-1:0] idargs;
     reg [2*CUM_WIDTH-1:0] valargs;

   begin
     if (verbose >= 2) $display("XTB: Starting macro test_setup..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("test_setup",38'b1, idargs);
     resolve_wft(1);

     assign_val('d`all_inputs , 24'b000000000000XXXXXXXXXXXX);
     assign_val('d`all_outputs , 38'b1111111111111111111XXXXXXXXXXXXXXXXXXX);

     assign_val('d`clk , 2'b00);
     assign_stmt(the_wft_id);

     assign_stmt(the_wft_id);

   end 
   endtask

   task shift_0;
     input [SIG_IDS-1:0] idargs;
     input [2*CUM_WIDTH-1:0] valargs;
     input stsci;
     input stroben;
     reg [SIG_IDS-1:0] idargs;
     reg [2*CUM_WIDTH-1:0] valargs;
     integer stsci;
     reg stroben;

   begin
    csci = stsci+0; prev_error = -2;
    while (csci < 132) begin
     fsci = csci;
     if (verbose >= 2) $display("XTB: shift %0d, at %0t ", csci, $time);
     resolve_wft(1);
     assign_val('d`_clk , 2'bZ1);
         if (idargs[34] === 1'b1 || idargs[10] === 1'b1) begin 
           LOD=LOAD[0]; assign_val('d`test_si , {1'b0, LOD[csci+0]});
         end
         if (stroben && (idargs[37] === 1'b1 || idargs[30] === 1'b1)) begin 
           UNL = UNLOAD[0]; assign_val('d`test_so , {1'b1,  UNL[csci+0]});
         end
     assign_stmt(the_wft_id);
     csci = csci+1;
    end
   end
   endtask


   always /* ParallelShiftMode */ @(strobe_scells) begin
     CHAINOUT0[0:31] = {dut.test_so , dut.dp.wrd.q_reg_7_.TI , dut.dp.wrd.q_reg_6_.TI , dut.dp.wrd.q_reg_5_.TI , dut.dp.wrd.q_reg_4_.TI , dut.dp.wrd.q_reg_3_.TI , dut.dp.wrd.q_reg_2_.TI , dut.dp.wrd.q_reg_1_.TI , dut.dp.wrd.q_reg_0_.TI , dut.dp.rf.RAM_reg_7__7_.TI , dut.dp.rf.RAM_reg_7__6_.TI , dut.dp.rf.RAM_reg_7__5_.TI , dut.dp.rf.RAM_reg_7__4_.TI , dut.dp.rf.RAM_reg_7__3_.TI , dut.dp.rf.RAM_reg_7__2_.TI , dut.dp.rf.RAM_reg_7__1_.TI , dut.dp.rf.RAM_reg_7__0_.TI , dut.dp.rf.RAM_reg_6__7_.TI , dut.dp.rf.RAM_reg_6__6_.TI , dut.dp.rf.RAM_reg_6__5_.TI , dut.dp.rf.RAM_reg_6__4_.TI , dut.dp.rf.RAM_reg_6__3_.TI , dut.dp.rf.RAM_reg_6__2_.TI , dut.dp.rf.RAM_reg_6__1_.TI , dut.dp.rf.RAM_reg_6__0_.TI , dut.dp.rf.RAM_reg_5__7_.TI , dut.dp.rf.RAM_reg_5__6_.TI , dut.dp.rf.RAM_reg_5__5_.TI , dut.dp.rf.RAM_reg_5__4_.TI , dut.dp.rf.RAM_reg_5__3_.TI , dut.dp.rf.RAM_reg_5__2_.TI , dut.dp.rf.RAM_reg_5__1_.TI };
     CHAINOUT0[32:63] = {dut.dp.rf.RAM_reg_5__0_.TI , dut.dp.rf.RAM_reg_4__7_.TI , dut.dp.rf.RAM_reg_4__6_.TI , dut.dp.rf.RAM_reg_4__5_.TI , dut.dp.rf.RAM_reg_4__4_.TI , dut.dp.rf.RAM_reg_4__3_.TI , dut.dp.rf.RAM_reg_4__2_.TI , dut.dp.rf.RAM_reg_4__1_.TI , dut.dp.rf.RAM_reg_4__0_.TI , dut.dp.rf.RAM_reg_3__7_.TI , dut.dp.rf.RAM_reg_3__6_.TI , dut.dp.rf.RAM_reg_3__5_.TI , dut.dp.rf.RAM_reg_3__4_.TI , dut.dp.rf.RAM_reg_3__3_.TI , dut.dp.rf.RAM_reg_3__2_.TI , dut.dp.rf.RAM_reg_3__1_.TI , dut.dp.rf.RAM_reg_3__0_.TI , dut.dp.rf.RAM_reg_2__7_.TI , dut.dp.rf.RAM_reg_2__6_.TI , dut.dp.rf.RAM_reg_2__5_.TI , dut.dp.rf.RAM_reg_2__4_.TI , dut.dp.rf.RAM_reg_2__3_.TI , dut.dp.rf.RAM_reg_2__2_.TI , dut.dp.rf.RAM_reg_2__1_.TI , dut.dp.rf.RAM_reg_2__0_.TI , dut.dp.rf.RAM_reg_1__7_.TI , dut.dp.rf.RAM_reg_1__6_.TI , dut.dp.rf.RAM_reg_1__5_.TI , dut.dp.rf.RAM_reg_1__4_.TI , dut.dp.rf.RAM_reg_1__3_.TI , dut.dp.rf.RAM_reg_1__2_.TI , dut.dp.rf.RAM_reg_1__1_.TI };
     CHAINOUT0[64:95] = {dut.dp.rf.RAM_reg_1__0_.TI , dut.dp.res.q_reg_7_.TI , dut.dp.res.q_reg_6_.TI , dut.dp.res.q_reg_5_.TI , dut.dp.res.q_reg_4_.TI , dut.dp.res.q_reg_3_.TI , dut.dp.res.q_reg_2_.TI , dut.dp.res.q_reg_1_.TI , dut.dp.res.q_reg_0_.TI , dut.dp.pcreg.q_reg_7_.TI , dut.dp.pcreg.q_reg_6_.TI , dut.dp.pcreg.q_reg_5_.TI , dut.dp.pcreg.q_reg_4_.TI , dut.dp.pcreg.q_reg_3_.TI , dut.dp.pcreg.q_reg_2_.TI , dut.dp.pcreg.q_reg_1_.TI , dut.dp.pcreg.q_reg_0_.TI , dut.dp.mdr.q_reg_7_.TI , dut.dp.mdr.q_reg_6_.TI , dut.dp.mdr.q_reg_5_.TI , dut.dp.mdr.q_reg_4_.TI , dut.dp.mdr.q_reg_3_.TI , dut.dp.mdr.q_reg_2_.TI , dut.dp.mdr.q_reg_1_.TI , dut.dp.mdr.q_reg_0_.TI , dut.dp.ir3.q_reg_7_.TI , dut.dp.ir3.q_reg_6_.TI , dut.dp.ir3.q_reg_5_.TI , dut.dp.ir3.q_reg_4_.TI , dut.dp.ir3.q_reg_3_.TI , dut.dp.ir3.q_reg_2_.TI , dut.dp.ir3.q_reg_1_.TI };
     CHAINOUT0[96:127] = {dut.dp.ir3.q_reg_0_.TI , dut.dp.ir2.q_reg_7_.TI , dut.dp.ir2.q_reg_6_.TI , dut.dp.ir2.q_reg_5_.TI , dut.dp.ir2.q_reg_4_.TI , dut.dp.ir2.q_reg_3_.TI , dut.dp.ir2.q_reg_2_.TI , dut.dp.ir2.q_reg_1_.TI , dut.dp.ir2.q_reg_0_.TI , dut.dp.ir1.q_reg_7_.TI , dut.dp.ir1.q_reg_6_.TI , dut.dp.ir1.q_reg_5_.TI , dut.dp.ir1.q_reg_4_.TI , dut.dp.ir1.q_reg_3_.TI , dut.dp.ir1.q_reg_2_.TI , dut.dp.ir1.q_reg_1_.TI , dut.dp.ir1.q_reg_0_.TI , dut.dp.ir0.q_reg_7_.TI , dut.dp.ir0.q_reg_6_.TI , dut.dp.ir0.q_reg_5_.TI , dut.dp.ir0.q_reg_4_.TI , dut.dp.ir0.q_reg_3_.TI , dut.dp.ir0.q_reg_2_.TI , dut.dp.ir0.q_reg_1_.TI , dut.dp.ir0.q_reg_0_.TI , dut.dp.areg.q_reg_7_.TI , dut.dp.areg.q_reg_6_.TI , dut.dp.areg.q_reg_5_.TI , dut.dp.areg.q_reg_4_.TI , dut.dp.areg.q_reg_3_.TI , dut.dp.areg.q_reg_2_.TI , dut.dp.areg.q_reg_1_.TI };
     CHAINOUT0[128:131] = {dut.dp.areg.q_reg_0_.TI , dut.cont.state_reg_3_.TI , dut.cont.state_reg_2_.TI , dut.cont.state_reg_1_.TI };
   end

   `define CELL0IN0 dut.cont.state_reg_0_.TI
   `define CHAININ0 {dut.dp.wrd.q_reg_7_.TI , dut.dp.wrd.q_reg_6_.TI , dut.dp.wrd.q_reg_5_.TI , dut.dp.wrd.q_reg_4_.TI , dut.dp.wrd.q_reg_3_.TI , dut.dp.wrd.q_reg_2_.TI , dut.dp.wrd.q_reg_1_.TI , dut.dp.wrd.q_reg_0_.TI , dut.dp.rf.RAM_reg_7__7_.TI , dut.dp.rf.RAM_reg_7__6_.TI , dut.dp.rf.RAM_reg_7__5_.TI , dut.dp.rf.RAM_reg_7__4_.TI , dut.dp.rf.RAM_reg_7__3_.TI , dut.dp.rf.RAM_reg_7__2_.TI , dut.dp.rf.RAM_reg_7__1_.TI , dut.dp.rf.RAM_reg_7__0_.TI , dut.dp.rf.RAM_reg_6__7_.TI , dut.dp.rf.RAM_reg_6__6_.TI , dut.dp.rf.RAM_reg_6__5_.TI , dut.dp.rf.RAM_reg_6__4_.TI , dut.dp.rf.RAM_reg_6__3_.TI , dut.dp.rf.RAM_reg_6__2_.TI , dut.dp.rf.RAM_reg_6__1_.TI , dut.dp.rf.RAM_reg_6__0_.TI , dut.dp.rf.RAM_reg_5__7_.TI , dut.dp.rf.RAM_reg_5__6_.TI , dut.dp.rf.RAM_reg_5__5_.TI , dut.dp.rf.RAM_reg_5__4_.TI , dut.dp.rf.RAM_reg_5__3_.TI , dut.dp.rf.RAM_reg_5__2_.TI , dut.dp.rf.RAM_reg_5__1_.TI , dut.dp.rf.RAM_reg_5__0_.TI , dut.dp.rf.RAM_reg_4__7_.TI , dut.dp.rf.RAM_reg_4__6_.TI , dut.dp.rf.RAM_reg_4__5_.TI , dut.dp.rf.RAM_reg_4__4_.TI , dut.dp.rf.RAM_reg_4__3_.TI , \
	dut.dp.rf.RAM_reg_4__2_.TI , dut.dp.rf.RAM_reg_4__1_.TI , dut.dp.rf.RAM_reg_4__0_.TI , dut.dp.rf.RAM_reg_3__7_.TI , dut.dp.rf.RAM_reg_3__6_.TI , dut.dp.rf.RAM_reg_3__5_.TI , dut.dp.rf.RAM_reg_3__4_.TI , dut.dp.rf.RAM_reg_3__3_.TI , dut.dp.rf.RAM_reg_3__2_.TI , dut.dp.rf.RAM_reg_3__1_.TI , dut.dp.rf.RAM_reg_3__0_.TI , dut.dp.rf.RAM_reg_2__7_.TI , dut.dp.rf.RAM_reg_2__6_.TI , dut.dp.rf.RAM_reg_2__5_.TI , dut.dp.rf.RAM_reg_2__4_.TI , dut.dp.rf.RAM_reg_2__3_.TI , dut.dp.rf.RAM_reg_2__2_.TI , dut.dp.rf.RAM_reg_2__1_.TI , dut.dp.rf.RAM_reg_2__0_.TI , dut.dp.rf.RAM_reg_1__7_.TI , dut.dp.rf.RAM_reg_1__6_.TI , dut.dp.rf.RAM_reg_1__5_.TI , dut.dp.rf.RAM_reg_1__4_.TI , dut.dp.rf.RAM_reg_1__3_.TI , dut.dp.rf.RAM_reg_1__2_.TI , dut.dp.rf.RAM_reg_1__1_.TI , dut.dp.rf.RAM_reg_1__0_.TI , dut.dp.res.q_reg_7_.TI , dut.dp.res.q_reg_6_.TI , dut.dp.res.q_reg_5_.TI , dut.dp.res.q_reg_4_.TI , dut.dp.res.q_reg_3_.TI , dut.dp.res.q_reg_2_.TI , dut.dp.res.q_reg_1_.TI , dut.dp.res.q_reg_0_.TI , dut.dp.pcreg.q_reg_7_.TI , dut.dp.pcreg.q_reg_6_.TI , dut.dp.pcreg.q_reg_5_.TI , dut.dp.pcreg.q_reg_4_.TI , dut.dp.pcreg.q_reg_3_.TI , dut.dp.pcreg.q_reg_2_.TI , dut.dp.pcreg.q_reg_1_.TI , dut.dp.pcreg.q_reg_0_.TI , dut.dp.mdr.q_reg_7_.TI , dut.dp.mdr.q_reg_6_.TI , dut.dp.mdr.q_reg_5_.TI , dut.dp.mdr.q_reg_4_.TI , \
	dut.dp.mdr.q_reg_3_.TI , dut.dp.mdr.q_reg_2_.TI , dut.dp.mdr.q_reg_1_.TI , dut.dp.mdr.q_reg_0_.TI , dut.dp.ir3.q_reg_7_.TI , dut.dp.ir3.q_reg_6_.TI , dut.dp.ir3.q_reg_5_.TI , dut.dp.ir3.q_reg_4_.TI , dut.dp.ir3.q_reg_3_.TI , dut.dp.ir3.q_reg_2_.TI , dut.dp.ir3.q_reg_1_.TI , dut.dp.ir3.q_reg_0_.TI , dut.dp.ir2.q_reg_7_.TI , dut.dp.ir2.q_reg_6_.TI , dut.dp.ir2.q_reg_5_.TI , dut.dp.ir2.q_reg_4_.TI , dut.dp.ir2.q_reg_3_.TI , dut.dp.ir2.q_reg_2_.TI , dut.dp.ir2.q_reg_1_.TI , dut.dp.ir2.q_reg_0_.TI , dut.dp.ir1.q_reg_7_.TI , dut.dp.ir1.q_reg_6_.TI , dut.dp.ir1.q_reg_5_.TI , dut.dp.ir1.q_reg_4_.TI , dut.dp.ir1.q_reg_3_.TI , dut.dp.ir1.q_reg_2_.TI , dut.dp.ir1.q_reg_1_.TI , dut.dp.ir1.q_reg_0_.TI , dut.dp.ir0.q_reg_7_.TI , dut.dp.ir0.q_reg_6_.TI , dut.dp.ir0.q_reg_5_.TI , dut.dp.ir0.q_reg_4_.TI , dut.dp.ir0.q_reg_3_.TI , dut.dp.ir0.q_reg_2_.TI , dut.dp.ir0.q_reg_1_.TI , dut.dp.ir0.q_reg_0_.TI , dut.dp.areg.q_reg_7_.TI , dut.dp.areg.q_reg_6_.TI , dut.dp.areg.q_reg_5_.TI , dut.dp.areg.q_reg_4_.TI , dut.dp.areg.q_reg_3_.TI , dut.dp.areg.q_reg_2_.TI , dut.dp.areg.q_reg_1_.TI , dut.dp.areg.q_reg_0_.TI , dut.cont.state_reg_3_.TI , dut.cont.state_reg_2_.TI , dut.cont.state_reg_1_.TI ,  `CELL0IN0 }


   task p_shift_0;
     input [SIG_IDS-1:0] idargs;
     input [2*CUM_WIDTH-1:0] valargs;
     reg [SIG_IDS-1:0] idargs;
     reg [2*CUM_WIDTH-1:0] valargs;

     integer i, j;
   begin
     if (~(idargs[34] | idargs[10] | idargs[37] | idargs[30] )) 
       disable p_shift_0; 
     if (SSHIFTS < MAXCHLEN) begin
         if (verbose >= 2) $display("XTB: (parallel) shift, at %0t  ", $time);
         resolve_wft(1);
     fork 
       begin: b1 
         #40 ;
         -> strobe_scells;
         repeat (SYNC_LATENCY) #0;
         if (idargs[37] === 1'b1 ||  idargs[30] === 1'b1) begin 
           measure_chain_out('d0);
         end
         if (idargs[34] === 1'b1 ||  idargs[10] === 1'b1) begin 
           LOD0=(LOAD[0] >> SSHIFTS) ^ CH_INPINV[0];
         end

           ->force_scells; 
         #0;
       end 
       begin: b2 
         assign_val('d`_clk , 2'bZ1);
         assign_stmt(the_wft_id);
       end 
     join 

     ->release_scells; 

         if (sertmg == 1) begin
           v_count = v_count + PARSERINC - SSHIFTS - 1;
           for (i = 0; i < PARSERINC - SSHIFTS - 1; i = i+1) 
             complete_cycle(the_wft_id);
         end
         if (SSHIFTS > 0) shift_0(idargs, valargs, MAXCHLEN-SSHIFTS, 0) ; 

     end 
     else begin 
         shift_0(idargs, valargs, 0, 1);
     end
   end
   endtask


   always /* ParallelShiftMode */ @(force_scells) begin 
           force `CHAININ0 = LOD0;

   end


   always /* ParallelShiftMode */ @(release_scells) begin 
     release `CHAININ0; 
   end

   task load_unload;
     input [SIG_IDS-1:0] idargs;
     input [2*CUM_WIDTH-1:0] valargs;
     reg [SIG_IDS-1:0] idargs;
     reg [2*CUM_WIDTH-1:0] valargs;

   begin
     if (verbose >= 2) $display("XTB: Starting proc load_unload..., T=%0t, V=%0d", $time, v_count+1);

     if (xtb_sim_mode == 0 && ser_pats > 0 && cur_pat == (ser_pats+first_pat)) begin
       $display("XTB: Switching into Parallel simulation mode at pattern %0d (using %0d serial shifts)", cur_pat, SSHIFTS);
       xtb_sim_mode = 1; 
     end
     if (cur_pat != prev_pat) begin
       loads = 1;
       prev_pat = cur_pat;
       if (cur_pat % rep_pat == 0)
         $display("XTB: Begin %0s scan load for pattern %0d (T=%0t, V=%0d)", xtb_sim_mode?"parallel":"serial", cur_pat, $time, v_count+1);
     end
     else begin
       loads = loads + 1;
       if (cur_pat % rep_pat == 0)
         $display("XTB: Begin %0s scan load for pattern %0d, unload %0d (T=%0t, V=%0d)", xtb_sim_mode?"parallel":"serial", cur_pat, loads, $time, v_count+1);
     end
     save_context;
     resolve_wft(1);

     assign_val('d`all_inputs , 24'b0000000000000XXXXXXXXXXX);
     assign_val('d`all_outputs , 38'b1111111111111111111XXXXXXXXXXXXXXXXXXX);

     assign_val('d`test_se , 2'b01);
     assign_stmt(the_wft_id);

     if (xtb_sim_mode)      p_shift_0(idargs, valargs);
     else      shift_0(idargs, valargs, 0, 1);

     restore_context;
   end 
   endtask

   task multiclock_capture;
     input [SIG_IDS-1:0] idargs;
     input [2*CUM_WIDTH-1:0] valargs;
     reg [SIG_IDS-1:0] idargs;
     reg [2*CUM_WIDTH-1:0] valargs;

   begin
     if (verbose >= 2) $display("XTB: Starting proc multiclock_capture..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("multiclock_capture",38'b1, idargs);
     save_context;
     resolve_wft(0);

     assign_val('d`all_inputs , 24'b0000000000000XXXXXXXXXXX);
     assign_val('d`all_outputs , 38'b1111111111111111111XXXXXXXXXXXXXXXXXXX);

     if (idargs[31] === 1'b1) assign_ival('d`_pi );
     if (idargs[0] === 1'b1) assign_ival('d`clk );
     if (idargs[9] === 1'b1) assign_ival('d`\memdata[0]  );
     if (idargs[8] === 1'b1) assign_ival('d`\memdata[1]  );
     if (idargs[7] === 1'b1) assign_ival('d`\memdata[2]  );
     if (idargs[6] === 1'b1) assign_ival('d`\memdata[3]  );
     if (idargs[5] === 1'b1) assign_ival('d`\memdata[4]  );
     if (idargs[4] === 1'b1) assign_ival('d`\memdata[5]  );
     if (idargs[3] === 1'b1) assign_ival('d`\memdata[6]  );
     if (idargs[2] === 1'b1) assign_ival('d`\memdata[7]  );
     if (idargs[1] === 1'b1) assign_ival('d`reset );
     if (idargs[10] === 1'b1) assign_ival('d`test_si );
     if (idargs[11] === 1'b1) assign_ival('d`test_se );
     if (idargs[33] === 1'b1) assign_ival('d`_po );
     if (idargs[21] === 1'b1) assign_ival('d`\adr[0]  );
     if (idargs[20] === 1'b1) assign_ival('d`\adr[1]  );
     if (idargs[19] === 1'b1) assign_ival('d`\adr[2]  );
     if (idargs[18] === 1'b1) assign_ival('d`\adr[3]  );
     if (idargs[17] === 1'b1) assign_ival('d`\adr[4]  );
     if (idargs[16] === 1'b1) assign_ival('d`\adr[5]  );
     if (idargs[15] === 1'b1) assign_ival('d`\adr[6]  );
     if (idargs[14] === 1'b1) assign_ival('d`\adr[7]  );
     if (idargs[12] === 1'b1) assign_ival('d`memread );
     if (idargs[13] === 1'b1) assign_ival('d`memwrite );
     if (idargs[29] === 1'b1) assign_ival('d`\writedata[0]  );
     if (idargs[28] === 1'b1) assign_ival('d`\writedata[1]  );
     if (idargs[27] === 1'b1) assign_ival('d`\writedata[2]  );
     if (idargs[26] === 1'b1) assign_ival('d`\writedata[3]  );
     if (idargs[25] === 1'b1) assign_ival('d`\writedata[4]  );
     if (idargs[24] === 1'b1) assign_ival('d`\writedata[5]  );
     if (idargs[23] === 1'b1) assign_ival('d`\writedata[6]  );
     if (idargs[22] === 1'b1) assign_ival('d`\writedata[7]  );
     if (idargs[30] === 1'b1) assign_ival('d`test_so );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask

   task allclock_launch_capture;
     input [SIG_IDS-1:0] idargs;
     input [2*CUM_WIDTH-1:0] valargs;
     reg [SIG_IDS-1:0] idargs;
     reg [2*CUM_WIDTH-1:0] valargs;

   begin
     if (verbose >= 2) $display("XTB: Starting proc allclock_launch_capture..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("allclock_launch_capture",38'b1, idargs);
     save_context;
     resolve_wft(2);

     assign_val('d`all_inputs , 24'b0000000000000XXXXXXXXXXX);
     assign_val('d`all_outputs , 38'b1111111111111111111XXXXXXXXXXXXXXXXXXX);

     if (idargs[31] === 1'b1) assign_ival('d`_pi );
     if (idargs[0] === 1'b1) assign_ival('d`clk );
     if (idargs[9] === 1'b1) assign_ival('d`\memdata[0]  );
     if (idargs[8] === 1'b1) assign_ival('d`\memdata[1]  );
     if (idargs[7] === 1'b1) assign_ival('d`\memdata[2]  );
     if (idargs[6] === 1'b1) assign_ival('d`\memdata[3]  );
     if (idargs[5] === 1'b1) assign_ival('d`\memdata[4]  );
     if (idargs[4] === 1'b1) assign_ival('d`\memdata[5]  );
     if (idargs[3] === 1'b1) assign_ival('d`\memdata[6]  );
     if (idargs[2] === 1'b1) assign_ival('d`\memdata[7]  );
     if (idargs[1] === 1'b1) assign_ival('d`reset );
     if (idargs[10] === 1'b1) assign_ival('d`test_si );
     if (idargs[11] === 1'b1) assign_ival('d`test_se );
     if (idargs[33] === 1'b1) assign_ival('d`_po );
     if (idargs[21] === 1'b1) assign_ival('d`\adr[0]  );
     if (idargs[20] === 1'b1) assign_ival('d`\adr[1]  );
     if (idargs[19] === 1'b1) assign_ival('d`\adr[2]  );
     if (idargs[18] === 1'b1) assign_ival('d`\adr[3]  );
     if (idargs[17] === 1'b1) assign_ival('d`\adr[4]  );
     if (idargs[16] === 1'b1) assign_ival('d`\adr[5]  );
     if (idargs[15] === 1'b1) assign_ival('d`\adr[6]  );
     if (idargs[14] === 1'b1) assign_ival('d`\adr[7]  );
     if (idargs[12] === 1'b1) assign_ival('d`memread );
     if (idargs[13] === 1'b1) assign_ival('d`memwrite );
     if (idargs[29] === 1'b1) assign_ival('d`\writedata[0]  );
     if (idargs[28] === 1'b1) assign_ival('d`\writedata[1]  );
     if (idargs[27] === 1'b1) assign_ival('d`\writedata[2]  );
     if (idargs[26] === 1'b1) assign_ival('d`\writedata[3]  );
     if (idargs[25] === 1'b1) assign_ival('d`\writedata[4]  );
     if (idargs[24] === 1'b1) assign_ival('d`\writedata[5]  );
     if (idargs[23] === 1'b1) assign_ival('d`\writedata[6]  );
     if (idargs[22] === 1'b1) assign_ival('d`\writedata[7]  );
     if (idargs[30] === 1'b1) assign_ival('d`test_so );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask

   task allclock_launch;
     input [SIG_IDS-1:0] idargs;
     input [2*CUM_WIDTH-1:0] valargs;
     reg [SIG_IDS-1:0] idargs;
     reg [2*CUM_WIDTH-1:0] valargs;

   begin
     if (verbose >= 2) $display("XTB: Starting proc allclock_launch..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("allclock_launch",38'b1, idargs);
     save_context;
     resolve_wft(3);

     assign_val('d`all_inputs , 24'b0000000000000XXXXXXXXXXX);
     assign_val('d`all_outputs , 38'b1111111111111111111XXXXXXXXXXXXXXXXXXX);

     if (idargs[31] === 1'b1) assign_ival('d`_pi );
     if (idargs[0] === 1'b1) assign_ival('d`clk );
     if (idargs[9] === 1'b1) assign_ival('d`\memdata[0]  );
     if (idargs[8] === 1'b1) assign_ival('d`\memdata[1]  );
     if (idargs[7] === 1'b1) assign_ival('d`\memdata[2]  );
     if (idargs[6] === 1'b1) assign_ival('d`\memdata[3]  );
     if (idargs[5] === 1'b1) assign_ival('d`\memdata[4]  );
     if (idargs[4] === 1'b1) assign_ival('d`\memdata[5]  );
     if (idargs[3] === 1'b1) assign_ival('d`\memdata[6]  );
     if (idargs[2] === 1'b1) assign_ival('d`\memdata[7]  );
     if (idargs[1] === 1'b1) assign_ival('d`reset );
     if (idargs[10] === 1'b1) assign_ival('d`test_si );
     if (idargs[11] === 1'b1) assign_ival('d`test_se );
     if (idargs[33] === 1'b1) assign_ival('d`_po );
     if (idargs[21] === 1'b1) assign_ival('d`\adr[0]  );
     if (idargs[20] === 1'b1) assign_ival('d`\adr[1]  );
     if (idargs[19] === 1'b1) assign_ival('d`\adr[2]  );
     if (idargs[18] === 1'b1) assign_ival('d`\adr[3]  );
     if (idargs[17] === 1'b1) assign_ival('d`\adr[4]  );
     if (idargs[16] === 1'b1) assign_ival('d`\adr[5]  );
     if (idargs[15] === 1'b1) assign_ival('d`\adr[6]  );
     if (idargs[14] === 1'b1) assign_ival('d`\adr[7]  );
     if (idargs[12] === 1'b1) assign_ival('d`memread );
     if (idargs[13] === 1'b1) assign_ival('d`memwrite );
     if (idargs[29] === 1'b1) assign_ival('d`\writedata[0]  );
     if (idargs[28] === 1'b1) assign_ival('d`\writedata[1]  );
     if (idargs[27] === 1'b1) assign_ival('d`\writedata[2]  );
     if (idargs[26] === 1'b1) assign_ival('d`\writedata[3]  );
     if (idargs[25] === 1'b1) assign_ival('d`\writedata[4]  );
     if (idargs[24] === 1'b1) assign_ival('d`\writedata[5]  );
     if (idargs[23] === 1'b1) assign_ival('d`\writedata[6]  );
     if (idargs[22] === 1'b1) assign_ival('d`\writedata[7]  );
     if (idargs[30] === 1'b1) assign_ival('d`test_so );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask

   task allclock_capture;
     input [SIG_IDS-1:0] idargs;
     input [2*CUM_WIDTH-1:0] valargs;
     reg [SIG_IDS-1:0] idargs;
     reg [2*CUM_WIDTH-1:0] valargs;

   begin
     if (verbose >= 2) $display("XTB: Starting proc allclock_capture..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("allclock_capture",38'b1, idargs);
     save_context;
     resolve_wft(4);

     assign_val('d`all_inputs , 24'b0000000000000XXXXXXXXXXX);
     assign_val('d`all_outputs , 38'b1111111111111111111XXXXXXXXXXXXXXXXXXX);

     if (idargs[31] === 1'b1) assign_ival('d`_pi );
     if (idargs[0] === 1'b1) assign_ival('d`clk );
     if (idargs[9] === 1'b1) assign_ival('d`\memdata[0]  );
     if (idargs[8] === 1'b1) assign_ival('d`\memdata[1]  );
     if (idargs[7] === 1'b1) assign_ival('d`\memdata[2]  );
     if (idargs[6] === 1'b1) assign_ival('d`\memdata[3]  );
     if (idargs[5] === 1'b1) assign_ival('d`\memdata[4]  );
     if (idargs[4] === 1'b1) assign_ival('d`\memdata[5]  );
     if (idargs[3] === 1'b1) assign_ival('d`\memdata[6]  );
     if (idargs[2] === 1'b1) assign_ival('d`\memdata[7]  );
     if (idargs[1] === 1'b1) assign_ival('d`reset );
     if (idargs[10] === 1'b1) assign_ival('d`test_si );
     if (idargs[11] === 1'b1) assign_ival('d`test_se );
     if (idargs[33] === 1'b1) assign_ival('d`_po );
     if (idargs[21] === 1'b1) assign_ival('d`\adr[0]  );
     if (idargs[20] === 1'b1) assign_ival('d`\adr[1]  );
     if (idargs[19] === 1'b1) assign_ival('d`\adr[2]  );
     if (idargs[18] === 1'b1) assign_ival('d`\adr[3]  );
     if (idargs[17] === 1'b1) assign_ival('d`\adr[4]  );
     if (idargs[16] === 1'b1) assign_ival('d`\adr[5]  );
     if (idargs[15] === 1'b1) assign_ival('d`\adr[6]  );
     if (idargs[14] === 1'b1) assign_ival('d`\adr[7]  );
     if (idargs[12] === 1'b1) assign_ival('d`memread );
     if (idargs[13] === 1'b1) assign_ival('d`memwrite );
     if (idargs[29] === 1'b1) assign_ival('d`\writedata[0]  );
     if (idargs[28] === 1'b1) assign_ival('d`\writedata[1]  );
     if (idargs[27] === 1'b1) assign_ival('d`\writedata[2]  );
     if (idargs[26] === 1'b1) assign_ival('d`\writedata[3]  );
     if (idargs[25] === 1'b1) assign_ival('d`\writedata[4]  );
     if (idargs[24] === 1'b1) assign_ival('d`\writedata[5]  );
     if (idargs[23] === 1'b1) assign_ival('d`\writedata[6]  );
     if (idargs[22] === 1'b1) assign_ival('d`\writedata[7]  );
     if (idargs[30] === 1'b1) assign_ival('d`test_so );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask


   always @(start_part) begin: _burst__pattern__proc_unit

     integer nbpats, i;
     reg [5:0] nargs, na;
     reg [5:0] args;

     integer tdf;
     nbpats = 0; cur_pat = -1;
     end_pat = 0; v_count = 0; v_count_per_pat = 0;
     nbfails = 0;
     prev_pat = -2; prev_error = -2; first_pat = 0;
     diagf = 0;
     if (verbose >= 1) $display("XTB: Reading test data file \"%s\" ",`TDATA_FILE);


     tdf = $fopen(`TDATA_FILE);
     if (!tdf) begin 	           
       $display("XTB Error: cannot open %0s file. Exiting...\n", `TDATA_FILE); 	           
       $finish;                    
     end 
     $fclose(tdf);  

     $readmemb(`TDATA_FILE, memall);

     data_i = 1; 
     popcode = 'd0;

     if (diagm > 0) begin
       if (diagm > 2) begin
         $display("XTB Warning: wrong diagnosis mode (%0d), using default mode 1 (pattern based)", diagm);
         diagm = 1 ; 
       end  
       `ifdef tmax_diag_file 
         diag_file = `tmax_diag_file;
       `else 
         diag_file = "mipstb.diag"; 
       `endif
       diagf = $fopen(diag_file);
       if (diagf == 0) begin
         $display("XTB Error: Unable to open diagnosis file %s (for writing). Exiting...", diag_file);
         $finish; 
       end
       if (verbose >= 1) $display("XTB: User requesting TetraMAX compliant diagnosis file: %0s", diag_file);
       $fdisplay(diagf, "// Serial scan error:       <pat#> \t<pin_name> \t<shift_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// USF Parallel scan error: <pat#> \t<pin_name> \t<shift_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// DSF Parallel scan error: <pat#> \t<chain_name> \t<cell_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// Capture error:           <pat#> \t<pin_name> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// Cycle based error:          C \t<pin_name> \t<vect_nbr> \t(<expected_value> <simulated_value>)\n\n");

     end 

     memel = memall[data_i]; 
     total_pats = memel[31:0];
     data_i=data_i+1;

     last_pat = -1;

     if (total_pats < 0 || |(total_pats) === 1'bx) begin
       $display("XTB Error: Inconsistent total number of patterns (%d). Exiting...",  total_pats);
       $finish;
     end

     if (verbose >= 1) $display("XTB: Total number of patterns  %0d",  total_pats); 
     if (last_pat == -1) last_pat = total_pats - 1;

     if (last_pat >= total_pats) begin
     $display("XTB Error: Patterns simulation (%0d) exceeds total pattern count (%0d). Exiting...",  last_pat+1,total_pats);
     $finish;
     end

     `ifdef tmax_n_pattern_sim
     last_pat=`tmax_n_pattern_sim;
     if (verbose >= 2) $display("XTB: User requesting simulating patterns 0 to %0d",last_pat);
     if (last_pat < 0)  begin 
     $display("XTB Error: User requesting simulating wrong number of patterns (%d). Exiting... ",last_pat);
     $finish;
     end
     `endif

     xtb_sim_mode = 0;
     SSHIFTS = DFSHIFTS;

     ser_pats = last_pat + 1;

     `ifdef tmax_serial
       xtb_sim_mode = 0; 
       if (~(`tmax_serial & 1'b1) == 1'b0) 
         ser_pats = last_pat + 1;
       else 
         ser_pats = `tmax_serial + 0;
       `ifdef tmax_parallel 
         SSHIFTS = `tmax_parallel + 0; 
         if (ser_pats  >= last_pat + 1) begin	 
           $display("XTB Warning: requesting full serial simulation and full parallel simulation in the same time. Performing the default serial simulation mode...");
           xtb_sim_mode = 0;
         end 
       `endif
       if (ser_pats < last_pat + 1)
         xtb_sim_mode = ser_pats > 0 ? 0 : 1;
     `else 
       `ifdef tmax_parallel
         xtb_sim_mode = 1;
         SSHIFTS = `tmax_parallel + 0; 
       `endif 
     `endif
     if (SSHIFTS < 0) begin
       $display("XTB Error: Passing negative value (%0d) of serial shifts in parallel mode. Exiting...",  SSHIFTS);
       $finish; 
     end

     `ifdef tmax_serial_timing 
       sertmg = 1;
       if (xtb_sim_mode == 1) $display("XTB: Parallel simulation (timing and vector) extended to match serial simulation");
     `else 
       sertmg = 0; 
     `endif


     $display("XTB: Starting %0s simulation of %0d patterns", xtb_sim_mode == 0 ? "serial" : "parallel", xtb_sim_mode == 0 ? ((ser_pats>last_pat || ser_pats==0)?(last_pat+1):ser_pats): last_pat + 1);
     if (xtb_sim_mode) $display("XTB: Using %0d serial shifts", SSHIFTS);

     if (SSHIFTS >= MAXCHLEN)  begin 
       $display("XTB Warning: serial shifts (%0d) equals or exceeds max chain length (%0d). Performing full serial scan... ", SSHIFTS, MAXCHLEN); 
       xtb_sim_mode = 0;	
     end 

     if (diagm==2 && xtb_sim_mode==1)  begin 
       $display("XTB Warning: cannot display cycle-based diagnostic messages in parallel load mode simulation. Simulation will display pattern-based diagnostic messages."); 
       diagm = 1;	
     end 

     while (cur_pat <= last_pat && end_pat != 1) begin
       memel = memall[data_i];
       opcode = memel[3:0];
       cur_stmt = -1;
       args = 'b0;
       case (opcode)
         'd`EndPat:  begin
                       cur_stmt = `EndPat;
                       end_pat = 1;
                     end
         'd`IncPat:  begin
                       cur_stmt = `IncPat;
                       cur_pat = cur_pat + 1;
                       v_count_per_pat = 0;
                       nbpats = nbpats+1;
                     end
         'd`SetPat:  begin
                       cur_stmt = `SetPat;
                       if (cur_pat==-1) begin first_pat = memel[27:4]; cur_pat = first_pat; end
                       else cur_pat = memel[27:4];
                       v_count_per_pat = 0;
                       last_pat = last_pat + cur_pat; 
                       nbpats = nbpats+1;  
                     end
         'd`WFTStmt: begin
                       cur_stmt = `WFTStmt;
                       resolve_wft(memel[6:4]);
                     end 
         'd`ConditionStmt, 'd`FixedStmt, 'd`VectorStmt: begin
           if (opcode == 'd`ConditionStmt) cur_stmt = 'd`ConditionStmt;
           else 	cur_stmt='d`VectorStmt;
           nargs = memel[9:4];
           na = 0;
           while (na<nargs) begin
             data_i = data_i + 1;
             memel = memall[data_i];
             assign_val(memel[SIG_IDS_W-1:0], memel[2*MAX_WIDTH+SIG_IDS_W-1:SIG_IDS_W]);
             na = na + 1;
           end
           if (opcode == `VectorStmt) assign_stmt(the_wft_id);
          end 
         'd`test_setupStmt: begin: test_setup_BLOCK
           cur_stmt = `test_setupStmt;
           set_args(memel[9:4]);
           test_setup(sid_args, sval_args);
         end 
         'd`load_unloadStmt: begin: load_unload_BLOCK
           cur_stmt = `load_unloadStmt;
            na = 0; nargs = 'b0; sid_args = 'b0; sval_args = 'b0;
            nargs = memel[9:4];
            while (na < nargs) begin
              data_i = data_i + 1;
              memel = memall[data_i];
              if (memel[SIG_IDS_W-1:0] > SIG_IDS-1) begin
                $display("\nXTB Error: Passing wrong signal ID (%b), valid range is 1..%d. Exiting...", memel[SIG_IDS_W-1:0], SIG_IDS-1);
                $finish;
              end
              sid_args[memel[SIG_IDS_W-1:0]] = 1'b1;
              case (memel[SIG_IDS_W-1:0])
               'd`_si , 'd`test_si: begin LOAD[0] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               'd`_so , 'd`test_so: begin UNLOAD[0] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               default: begin  
                 $display("\nXTB Error: Wrong signal argument (%s) passed to load_unload procedure. Exiting...", SignalIDName[memel[SIG_IDS_W-1:0]]);
                 $finish; 
               end 
             endcase 
             na = na+1;
           end
           load_unload(sid_args, sval_args);
         end 
         'd`multiclock_captureStmt: begin: multiclock_capture_BLOCK
           cur_stmt = `multiclock_captureStmt;
           set_args(memel[9:4]);
           multiclock_capture(sid_args, sval_args);
         end 
         'd`allclock_launch_captureStmt: begin: allclock_launch_capture_BLOCK
           cur_stmt = `allclock_launch_captureStmt;
           set_args(memel[9:4]);
           allclock_launch_capture(sid_args, sval_args);
         end 
         'd`allclock_launchStmt: begin: allclock_launch_BLOCK
           cur_stmt = `allclock_launchStmt;
           set_args(memel[9:4]);
           allclock_launch(sid_args, sval_args);
         end 
         'd`allclock_captureStmt: begin: allclock_capture_BLOCK
           cur_stmt = `allclock_captureStmt;
           set_args(memel[9:4]);
           allclock_capture(sid_args, sval_args);
         end 
         default: begin $display("\nXTB Error: Unrecognized code %0h, @ inst %0d", opcode, data_i); $finish; end 
       endcase 
       data_i = data_i + 1;
       popcode = opcode;
       if (verbose >= 3) display_stmt(cur_stmt);
     end 
     $display("XTB: Simulation of %0d pattern%s completed with %0d error%s (time: %0t, cycles: %0d)\n", nbpats+end_pat-1, nbpats>1?"s":"", nbfails, nbfails>1?"s":"", $time, v_count); 

     if (diagf) $fclose(diagf);
     ->end_part;
   end 


   initial begin: _burst__pattern__init_unit


     for (n=0; n<SIG_IDS; n=n+1) SignalIDWidth[n] = 0;
     SignalIDName[0] = "clk";
     SignalIDType[0] = 0; //clk
     SignalIDWidth[0] = 1; //clk
     SignalIDName[1] = "reset";
     SignalIDType[1] = 0; //reset
     SignalIDWidth[1] = 1; //reset
     SignalIDName[2] = "\memdata[7] ";
     SignalIDType[2] = 0; //\memdata[7] 
     SignalIDWidth[2] = 1; //\memdata[7] 
     SignalIDName[3] = "\memdata[6] ";
     SignalIDType[3] = 0; //\memdata[6] 
     SignalIDWidth[3] = 1; //\memdata[6] 
     SignalIDName[4] = "\memdata[5] ";
     SignalIDType[4] = 0; //\memdata[5] 
     SignalIDWidth[4] = 1; //\memdata[5] 
     SignalIDName[5] = "\memdata[4] ";
     SignalIDType[5] = 0; //\memdata[4] 
     SignalIDWidth[5] = 1; //\memdata[4] 
     SignalIDName[6] = "\memdata[3] ";
     SignalIDType[6] = 0; //\memdata[3] 
     SignalIDWidth[6] = 1; //\memdata[3] 
     SignalIDName[7] = "\memdata[2] ";
     SignalIDType[7] = 0; //\memdata[2] 
     SignalIDWidth[7] = 1; //\memdata[2] 
     SignalIDName[8] = "\memdata[1] ";
     SignalIDType[8] = 0; //\memdata[1] 
     SignalIDWidth[8] = 1; //\memdata[1] 
     SignalIDName[9] = "\memdata[0] ";
     SignalIDType[9] = 0; //\memdata[0] 
     SignalIDWidth[9] = 1; //\memdata[0] 
     SignalIDName[10] = "test_si";
     SignalIDType[10] = 0; //test_si
     SignalIDWidth[10] = 1; //test_si
     SignalIDName[11] = "test_se";
     SignalIDType[11] = 0; //test_se
     SignalIDWidth[11] = 1; //test_se
     SignalIDName[12] = "memread";
     SignalIDType[12] = 1; //memread
     SignalIDWidth[12] = 1; //memread
     SignalIDName[13] = "memwrite";
     SignalIDType[13] = 1; //memwrite
     SignalIDWidth[13] = 1; //memwrite
     SignalIDName[14] = "\adr[7] ";
     SignalIDType[14] = 1; //\adr[7] 
     SignalIDWidth[14] = 1; //\adr[7] 
     SignalIDName[15] = "\adr[6] ";
     SignalIDType[15] = 1; //\adr[6] 
     SignalIDWidth[15] = 1; //\adr[6] 
     SignalIDName[16] = "\adr[5] ";
     SignalIDType[16] = 1; //\adr[5] 
     SignalIDWidth[16] = 1; //\adr[5] 
     SignalIDName[17] = "\adr[4] ";
     SignalIDType[17] = 1; //\adr[4] 
     SignalIDWidth[17] = 1; //\adr[4] 
     SignalIDName[18] = "\adr[3] ";
     SignalIDType[18] = 1; //\adr[3] 
     SignalIDWidth[18] = 1; //\adr[3] 
     SignalIDName[19] = "\adr[2] ";
     SignalIDType[19] = 1; //\adr[2] 
     SignalIDWidth[19] = 1; //\adr[2] 
     SignalIDName[20] = "\adr[1] ";
     SignalIDType[20] = 1; //\adr[1] 
     SignalIDWidth[20] = 1; //\adr[1] 
     SignalIDName[21] = "\adr[0] ";
     SignalIDType[21] = 1; //\adr[0] 
     SignalIDWidth[21] = 1; //\adr[0] 
     SignalIDName[22] = "\writedata[7] ";
     SignalIDType[22] = 1; //\writedata[7] 
     SignalIDWidth[22] = 1; //\writedata[7] 
     SignalIDName[23] = "\writedata[6] ";
     SignalIDType[23] = 1; //\writedata[6] 
     SignalIDWidth[23] = 1; //\writedata[6] 
     SignalIDName[24] = "\writedata[5] ";
     SignalIDType[24] = 1; //\writedata[5] 
     SignalIDWidth[24] = 1; //\writedata[5] 
     SignalIDName[25] = "\writedata[4] ";
     SignalIDType[25] = 1; //\writedata[4] 
     SignalIDWidth[25] = 1; //\writedata[4] 
     SignalIDName[26] = "\writedata[3] ";
     SignalIDType[26] = 1; //\writedata[3] 
     SignalIDWidth[26] = 1; //\writedata[3] 
     SignalIDName[27] = "\writedata[2] ";
     SignalIDType[27] = 1; //\writedata[2] 
     SignalIDWidth[27] = 1; //\writedata[2] 
     SignalIDName[28] = "\writedata[1] ";
     SignalIDType[28] = 1; //\writedata[1] 
     SignalIDWidth[28] = 1; //\writedata[1] 
     SignalIDName[29] = "\writedata[0] ";
     SignalIDType[29] = 1; //\writedata[0] 
     SignalIDWidth[29] = 1; //\writedata[0] 
     SignalIDName[30] = "test_so";
     SignalIDType[30] = 1; //test_so
     SignalIDWidth[30] = 1; //test_so
     SignalIDName[31] = "_pi";
     SignalIDType[31] = 3; //_pi
     SignalIDWidth[31] = 12; //_pi
     SignalIDName[32] = "all_inputs";
     SignalIDType[32] = 3; //all_inputs
     SignalIDWidth[32] = 12; //all_inputs
     SignalIDName[33] = "_po";
     SignalIDType[33] = 3; //_po
     SignalIDWidth[33] = 19; //_po
     SignalIDName[34] = "_si";
     SignalIDType[34] = 3; //_si
     SignalIDWidth[34] = 1; //_si
     SignalIDName[35] = "all_outputs";
     SignalIDType[35] = 3; //all_outputs
     SignalIDWidth[35] = 19; //all_outputs
     SignalIDName[36] = "_clk";
     SignalIDType[36] = 3; //_clk
     SignalIDWidth[36] = 1; //_clk
     SignalIDName[37] = "_so";
     SignalIDType[37] = 3; //_so
     SignalIDWidth[37] = 1; //_so
     WFTIDName[0] = "_multiclock_capture_WFT_";
     WFTIDName[1] = "_default_WFT_";
     WFTIDName[2] = "_allclock_launch_capture_WFT_";
     WFTIDName[3] = "_allclock_launch_WFT_";
     WFTIDName[4] = "_allclock_capture_WFT_";
     StmtNames[0] = "EndPat";
     StmtNames[1] = "IncPat";
     StmtNames[2] = "SetPat";
     StmtNames[3] = "WFTStmt";
     StmtNames[4] = "ConditionStmt";
     StmtNames[5] = "VectorStmt";
     StmtNames[6] = "FixedStmt";
     StmtNames[7] = "test_setupStmt";
     StmtNames[8] = "load_unloadStmt";
     StmtNames[9] = "multiclock_captureStmt";
     StmtNames[10] = "allclock_launch_captureStmt";
     StmtNames[11] = "allclock_launchStmt";
     StmtNames[12] = "allclock_captureStmt";

     $display("%s",`MAXTB_H_S);
     $display("%s",`MAXTB_HEADER);
     $display("%s\n",`MAXTB_H_S);

     $timeformat(-9,2," ns",19);

     `ifdef tmax_test_data_file 
       `undef TDATA_FILE
       `define TDATA_FILE `tmax_test_data_file
        $display("XTB: test data file set to \"%s\"", `TDATA_FILE);
     `endif


     `ifdef tmax_vcde
       $display("XTB: Dumping Extended VCD information in file \"mipstb.vcd\"");
       $dumpports( dut, "mipstb.vcd");
     `endif

     `ifdef tmax_msg
       verbose = `tmax_msg ;
     `else
       verbose = 0 ;
     `endif

     `ifdef tmax_rpt
     rep_pat = `tmax_rpt ;
     `else
     rep_pat = 5 ;
     `endif

     CH_NAMES[0] = "1";
     CH_PINS[0] = "test_so";
     CH_OUTINV[0] = 132'b000000000000000001010101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000110;
     CH_INPINV[0] = 132'b111111111111111101010101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110010;

     diagm = 0;
     diag_file = "";

     `ifdef tmax_diag 
       diagm = `tmax_diag;
     `endif

     -> start_part;
     @(end_part) #0;
     $finish(0);

   end

	initial begin
		$shm_open("mips_tb.db");
		$shm_probe("AS");
	end

 endmodule
